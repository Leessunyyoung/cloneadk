{"ast":null,"code":"import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { addGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = _ref => {\n  let {\n    id,\n    path,\n    updatedGroupsManager,\n    tree,\n    treeDepths,\n    onDuplicatePath,\n    isGroupExpandedByDefault,\n    defaultGroupingExpansionDepth\n  } = _ref;\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath, _childrenFromPath$fie;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null ? void 0 : (_childrenFromPath$fie = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath$fie[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree({\n          node: leafNode,\n          tree,\n          treeDepths\n        });\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {}\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree({\n        node: addGroupDefaultExpansion({\n          node: autoGeneratedGroupNode,\n          defaultGroupingExpansionDepth,\n          isGroupExpandedByDefault\n        }),\n        tree,\n        treeDepths\n      });\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {}\n        };\n        tree[existingNodeIdWithPartialPath] = addGroupDefaultExpansion({\n          node: groupNode,\n          defaultGroupingExpansionDepth,\n          isGroupExpandedByDefault\n        });\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};","map":{"version":3,"names":["GRID_ROOT_GROUP_ID","addGroupDefaultExpansion","getGroupRowIdFromPath","insertNodeInTree","updateGroupNodeIdAndAutoGenerated","insertDataRowInTree","_ref","id","path","updatedGroupsManager","tree","treeDepths","onDuplicatePath","isGroupExpandedByDefault","defaultGroupingExpansionDepth","parentNodeId","depth","length","_childrenFromPath","_childrenFromPath$fie","key","field","fieldWithDefaultValue","keyWithDefaultValue","existingNodeIdWithPartialPath","childrenFromPath","toString","leafNode","type","parent","groupingKey","addAction","node","existingNodeWithPartialPath","isAutoGenerated","updatedNode","nodeId","slice","autoGeneratedGroupNode","groupingField","children","currentGroupNode","groupNode"],"sources":["/Users/sunyoung.lee/git/CloneADK-UI/node_modules/@mui/x-data-grid-pro/utils/tree/insertDataRowInTree.js"],"sourcesContent":["import { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nimport { addGroupDefaultExpansion, getGroupRowIdFromPath, insertNodeInTree, updateGroupNodeIdAndAutoGenerated } from './utils';\n/**\n * Inserts a data row in a tree.\n * For each steps of its path:\n * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.\n * - if not, it will create an auto-generated node and register it as ancestor of the data row.\n */\nexport const insertDataRowInTree = ({\n  id,\n  path,\n  updatedGroupsManager,\n  tree,\n  treeDepths,\n  onDuplicatePath,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let parentNodeId = GRID_ROOT_GROUP_ID;\n  for (let depth = 0; depth < path.length; depth += 1) {\n    var _childrenFromPath, _childrenFromPath$fie;\n    const {\n      key,\n      field\n    } = path[depth];\n    const fieldWithDefaultValue = field != null ? field : '__no_field__';\n    const keyWithDefaultValue = key != null ? key : '__no_key__';\n    const existingNodeIdWithPartialPath = (_childrenFromPath = tree[parentNodeId].childrenFromPath) == null ? void 0 : (_childrenFromPath$fie = _childrenFromPath[fieldWithDefaultValue]) == null ? void 0 : _childrenFromPath$fie[keyWithDefaultValue.toString()];\n\n    // When we reach the last step of the path,\n    // We need to create a node for the row passed to `insertNodeInTree`\n    if (depth === path.length - 1) {\n      // If no node matches the full path,\n      // We create a leaf node for the data row.\n      if (existingNodeIdWithPartialPath == null) {\n        const leafNode = {\n          type: 'leaf',\n          id,\n          depth,\n          parent: parentNodeId,\n          groupingKey: key\n        };\n        updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n        insertNodeInTree({\n          node: leafNode,\n          tree,\n          treeDepths\n        });\n      } else {\n        const existingNodeWithPartialPath = tree[existingNodeIdWithPartialPath];\n\n        // If we already have an auto-generated group matching the partial path,\n        // We replace it with the node from of data row passed to `insertNodeInTree`\n        if (existingNodeWithPartialPath.type === 'group' && existingNodeWithPartialPath.isAutoGenerated) {\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'removeChildren');\n          updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n          updateGroupNodeIdAndAutoGenerated({\n            tree,\n            treeDepths,\n            node: existingNodeWithPartialPath,\n            updatedNode: {\n              id,\n              isAutoGenerated: false\n            }\n          });\n        } else {\n          // If we have another row matching the partial path, then there is a duplicate in the dataset.\n          // We warn the user and skip the current row.\n          onDuplicatePath == null ? void 0 : onDuplicatePath(existingNodeIdWithPartialPath, id, path);\n        }\n      }\n    }\n    // For the intermediary steps of the path,\n    // We need to make sure that there is a node matching the partial path.\n    //\n    // If no node matches the partial path,\n    // We create an auto-generated group node.\n    else if (existingNodeIdWithPartialPath == null) {\n      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));\n      const autoGeneratedGroupNode = {\n        type: 'group',\n        id: nodeId,\n        parent: parentNodeId,\n        depth,\n        isAutoGenerated: true,\n        groupingKey: key,\n        groupingField: field,\n        children: [],\n        childrenFromPath: {}\n      };\n      updatedGroupsManager == null ? void 0 : updatedGroupsManager.addAction(parentNodeId, 'insertChildren');\n      insertNodeInTree({\n        node: addGroupDefaultExpansion({\n          node: autoGeneratedGroupNode,\n          defaultGroupingExpansionDepth,\n          isGroupExpandedByDefault\n        }),\n        tree,\n        treeDepths\n      });\n      parentNodeId = nodeId;\n    }\n    // For the intermediary steps of the path\n    // If a node matches the partial path, we use it as parent for the next step\n    else {\n      const currentGroupNode = tree[existingNodeIdWithPartialPath];\n\n      // If the node matching the partial path is not a group, we turn it into a group\n      if (currentGroupNode.type !== 'group') {\n        const groupNode = {\n          type: 'group',\n          id: currentGroupNode.id,\n          parent: currentGroupNode.parent,\n          depth: currentGroupNode.depth,\n          isAutoGenerated: false,\n          groupingKey: key,\n          groupingField: field,\n          children: [],\n          childrenFromPath: {}\n        };\n        tree[existingNodeIdWithPartialPath] = addGroupDefaultExpansion({\n          node: groupNode,\n          defaultGroupingExpansionDepth,\n          isGroupExpandedByDefault\n        });\n      }\n      parentNodeId = currentGroupNode.id;\n    }\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}