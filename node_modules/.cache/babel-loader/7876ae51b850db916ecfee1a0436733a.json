{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = _ref2 => {\n  let {\n    id,\n    tree\n  } = _ref2;\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const addGroupDefaultExpansion = _ref3 => {\n  let {\n    node,\n    isGroupExpandedByDefault,\n    defaultGroupingExpansionDepth\n  } = _ref3;\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  return _extends({}, node, {\n    childrenExpanded\n  });\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = _ref4 => {\n  let {\n    node,\n    tree,\n    treeDepths\n  } = _ref4;\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    tree[node.parent] = _extends({}, parentNode, {\n      footerId: node.id\n    });\n  } else if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingField = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKey = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    tree[node.parent] = _extends({}, parentNode, {\n      childrenFromPath: _extends({}, parentNode.childrenFromPath, {\n        [groupingField]: _extends({}, (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingField], {\n          [groupingKey.toString()]: node.id\n        })\n      }),\n      children: [...parentNode.children, node.id]\n    });\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = _ref5 => {\n  let {\n    node,\n    tree,\n    treeDepths\n  } = _ref5;\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2, _parentNode$childrenF2, _parentNode$childrenF3;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n    const _ref = (_parentNode$childrenF2 = (_parentNode$childrenF3 = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF3[groupingField]) != null ? _parentNode$childrenF2 : {},\n      _groupingKey$toString = groupingKey.toString(),\n      newChildrenFromPathWithField = _objectWithoutPropertiesLoose(_ref, [_groupingKey$toString].map(_toPropertyKey));\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = _extends({}, parentNode.childrenFromPath);\n    if (Object.keys(newChildrenFromPathWithField).length === 0) {\n      delete childrenFromPath[groupingField];\n    } else {\n      childrenFromPath[groupingField] = newChildrenFromPathWithField;\n    }\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = _ref6 => {\n  let {\n    node,\n    updatedNode,\n    tree,\n    treeDepths\n  } = _ref6;\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree({\n    node: groupNode,\n    tree,\n    treeDepths\n  });\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});","map":{"version":3,"names":["_objectWithoutPropertiesLoose","_toPropertyKey","_extends","GRID_ROOT_GROUP_ID","getGroupRowIdFromPath","path","pathStr","map","groupingCriteria","field","key","join","getNodePathInTree","_ref2","id","tree","node","push","type","groupingField","groupingKey","parent","reverse","addGroupDefaultExpansion","_ref3","isGroupExpandedByDefault","defaultGroupingExpansionDepth","childrenExpanded","depth","insertNodeInTree","_ref4","treeDepths","_treeDepths$node$dept","parentNode","footerId","_groupingField","_groupingKey","_parentNode$childrenF","childrenFromPath","toString","children","removeNodeFromTree","_ref5","nodeDepth","currentNodeCount","_groupingField2","_groupingKey2","_parentNode$childrenF2","_parentNode$childrenF3","_ref","_groupingKey$toString","newChildrenFromPathWithField","filter","childId","Object","keys","length","updateGroupNodeIdAndAutoGenerated","_ref6","updatedNode","forEach","groupNode","createUpdatedGroupsManager","value","addAction","groupId","action"],"sources":["/Users/sunyoung.lee/git/CloneADK-UI/node_modules/@mui/x-data-grid-pro/utils/tree/utils.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\nexport const getNodePathInTree = ({\n  id,\n  tree\n}) => {\n  const path = [];\n  let node = tree[id];\n  while (node.id !== GRID_ROOT_GROUP_ID) {\n    path.push({\n      field: node.type === 'leaf' ? null : node.groupingField,\n      key: node.groupingKey\n    });\n    node = tree[node.parent];\n  }\n  path.reverse();\n  return path;\n};\nexport const addGroupDefaultExpansion = ({\n  node,\n  isGroupExpandedByDefault,\n  defaultGroupingExpansionDepth\n}) => {\n  let childrenExpanded;\n  if (node.id === GRID_ROOT_GROUP_ID) {\n    childrenExpanded = true;\n  } else if (isGroupExpandedByDefault) {\n    childrenExpanded = isGroupExpandedByDefault(node);\n  } else {\n    childrenExpanded = defaultGroupingExpansionDepth === -1 || defaultGroupingExpansionDepth > node.depth;\n  }\n  return _extends({}, node, {\n    childrenExpanded\n  });\n};\n\n/**\n * Insert a node in the tree\n */\nexport const insertNodeInTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  var _treeDepths$node$dept;\n  // 1. Insert node in the tree.\n  tree[node.id] = node;\n\n  // 2. Increment the `treeDepths` object for the node's depth.\n  treeDepths[node.depth] = ((_treeDepths$node$dept = treeDepths[node.depth]) != null ? _treeDepths$node$dept : 0) + 1;\n\n  // 3. Register the new node in its parent.\n  const parentNode = tree[node.parent];\n  if (node.type === 'footer') {\n    // For footers,\n    // Register the node from its parent `footerId` property.\n    tree[node.parent] = _extends({}, parentNode, {\n      footerId: node.id\n    });\n  } else if (node.type === 'group' || node.type === 'leaf') {\n    var _groupingField, _groupingKey, _parentNode$childrenF;\n    // For groups and leaves,\n    // Register the node from its parents `children` and `childrenFromPath` properties.\n    const groupingField = (_groupingField = node.groupingField) != null ? _groupingField : '__no_field__';\n    const groupingKey = (_groupingKey = node.groupingKey) != null ? _groupingKey : '__no_key__';\n    tree[node.parent] = _extends({}, parentNode, {\n      childrenFromPath: _extends({}, parentNode.childrenFromPath, {\n        [groupingField]: _extends({}, (_parentNode$childrenF = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF[groupingField], {\n          [groupingKey.toString()]: node.id\n        })\n      }),\n      children: [...parentNode.children, node.id]\n    });\n  }\n};\n\n/**\n * Removes a node from the tree\n */\nexport const removeNodeFromTree = ({\n  node,\n  tree,\n  treeDepths\n}) => {\n  // 1. Remove node from the tree.\n  delete tree[node.id];\n\n  // 2. Decrement the `treeDepths` object for the node's depth.\n  const nodeDepth = node.depth;\n  const currentNodeCount = treeDepths[nodeDepth];\n  if (currentNodeCount === 1) {\n    delete treeDepths[nodeDepth];\n  } else {\n    treeDepths[nodeDepth] = currentNodeCount - 1;\n  }\n\n  // 3. Unregister the new node in its parent.\n  const parentNode = tree[node.parent];\n  // For footers,\n  // Unregister the node from its parent `footerId` property.\n  if (node.type === 'footer') {\n    tree[parentNode.id] = _extends({}, parentNode, {\n      footerId: null\n    });\n  }\n  // For groups and leaves,\n  // Unregister the node from its parents `children` and `childrenFromPath` properties.\n  else {\n    var _groupingField2, _groupingKey2, _parentNode$childrenF2, _parentNode$childrenF3;\n    const groupingField = (_groupingField2 = node.groupingField) != null ? _groupingField2 : '__no_field__';\n    const groupingKey = (_groupingKey2 = node.groupingKey) != null ? _groupingKey2 : '__no_key__';\n    const _ref = (_parentNode$childrenF2 = (_parentNode$childrenF3 = parentNode.childrenFromPath) == null ? void 0 : _parentNode$childrenF3[groupingField]) != null ? _parentNode$childrenF2 : {},\n      _groupingKey$toString = groupingKey.toString(),\n      newChildrenFromPathWithField = _objectWithoutPropertiesLoose(_ref, [_groupingKey$toString].map(_toPropertyKey));\n\n    // TODO rows v6: Can we avoid this linear complexity ?\n    const children = parentNode.children.filter(childId => childId !== node.id);\n    const childrenFromPath = _extends({}, parentNode.childrenFromPath);\n    if (Object.keys(newChildrenFromPathWithField).length === 0) {\n      delete childrenFromPath[groupingField];\n    } else {\n      childrenFromPath[groupingField] = newChildrenFromPathWithField;\n    }\n    tree[parentNode.id] = _extends({}, parentNode, {\n      children,\n      childrenFromPath\n    });\n  }\n};\n\n/**\n * Updates the `id` and `isAutoGenerated` properties of a group node.\n */\nexport const updateGroupNodeIdAndAutoGenerated = ({\n  node,\n  updatedNode,\n  tree,\n  treeDepths\n}) => {\n  // 1. Set the new parent for all children from the old group\n  node.children.forEach(childId => {\n    tree[childId] = _extends({}, tree[childId], {\n      parent: updatedNode.id\n    });\n  });\n\n  // 2. Remove the old group from the tree\n  removeNodeFromTree({\n    node,\n    tree,\n    treeDepths\n  });\n\n  // 3. Add the new group in the tree\n  const groupNode = _extends({}, node, updatedNode);\n  insertNodeInTree({\n    node: groupNode,\n    tree,\n    treeDepths\n  });\n};\nexport const createUpdatedGroupsManager = () => ({\n  value: {},\n  addAction(groupId, action) {\n    if (!this.value[groupId]) {\n      this.value[groupId] = {};\n    }\n    this.value[groupId][action] = true;\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}